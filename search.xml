<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker安装分布式组件</title>
      <link href="/2021/11/25/Docker%E5%AE%89%E8%A3%85%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/11/25/Docker%E5%AE%89%E8%A3%85%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker容器中安装MySQL、Redis、Nginx、RabbitMQ、MongoDB、Elasticsearch、Logstash、Kibana，基于CenterOS7.6。</p></blockquote><span id="more"></span><p><strong>Docker环境安装</strong></p><ul><li>安装yum-utils：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ul><li>为yum源添加docker仓库位置：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装docker：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><ul><li>启动docker：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><hr /><p><strong>Java安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java:8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">** run 启动一个镜像容器</span><br><span class="line">** -d 后台运行该容器</span><br><span class="line">** -I 以交互模式运行容器，通常与 -t 同时使用</span><br><span class="line">** -t 为容器重新分配一个伪输入终端</span><br><span class="line">*/</span><br><span class="line">docker run -d -it --name java java:8</span><br></pre></td></tr></table></figure><p><strong>MySQL安装</strong></p><ul><li>下载MySQL5.7的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><p>使用如下命令启动MySQL服务：</p><pre><code>          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name=mysql \ </span><br><span class="line">-v /data/mysql/log:/var/log/mysql \ </span><br><span class="line">-v /data/mysql/data:/var/lib/mysql \ </span><br><span class="line">-v /data/mysql/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \ </span><br><span class="line">-d mysql:5.7              </span><br></pre></td></tr></table></figure></code></pre></li><li><p>参数说明</p><ul><li>-p 3306:3306：将容器的3306端口映射到主机的3306端口</li><li>-v /data/mysql/conf:/etc/mysql：将配置文件夹挂在到主机</li><li>-v /data/mysql/log:/var/log/mysql：将日志文件夹挂载到主机</li><li>-v /data/mysql/data:/var/lib/mysql/：将数据文件夹挂载到主机</li><li>-e MYSQL_ROOT_PASSWORD=root：初始化root用户的密码</li></ul></li><li><p>进入运行MySQL的docker容器：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><ul><li>使用MySQL命令打开客户端：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot --default-character-set=utf8</span><br></pre></td></tr></table></figure><ul><li>创建mall数据库：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database mall character set utf8</span><br></pre></td></tr></table></figure><ul><li>安装上传下载插件，并将document/sql/mall.sql上传到Linux服务器上：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><ul><li>将mall.sql文件拷贝到mysql容器的/目录下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/mall.sql mysql:/</span><br></pre></td></tr></table></figure><ul><li>将sql文件导入到数据库：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mall; source /mall.sql;</span><br></pre></td></tr></table></figure><ul><li>创建一个reader:123456帐号并修改权限，使得任何ip都能访问：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;reader&#x27; @&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><hr /><p><strong>Redis安装</strong></p><ul><li>下载Redis5.0的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5</span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动Redis服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name=redis \ </span><br><span class="line">-v /data/redis/data:/data \ </span><br><span class="line">-d redis:5 redis-server --appendonly yes</span><br></pre></td></tr></table></figure><ul><li>进入Redis容器使用redis-cli命令进行连接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure><p><img src="/Users/wustmz/Documents/redis.jpg" alt="redis" /></p><hr /><p><strong>Nginx安装</strong></p><ul><li>下载Nginx1.10的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.10</span><br></pre></td></tr></table></figure><ul><li>先运行一次容器（为了拷贝配置文件）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name=nginx \ </span><br><span class="line">-v /data/nginx/html:/usr/share/nginx/html \ </span><br><span class="line">-v /data/nginx/logs:/var/log/nginx  \ </span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure><ul><li>将容器内的配置文件拷贝到指定目录：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp nginx:/etc/nginx /data/nginx/</span><br></pre></td></tr></table></figure><ul><li>修改文件名称：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx conf</span><br></pre></td></tr></table></figure><ul><li>终止并删除容器：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx docker rm nginx</span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动Nginx服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name=nginx \ </span><br><span class="line">-v /data/nginx/html:/usr/share/nginx/html \ </span><br><span class="line">-v /data/nginx/logs:/var/log/nginx  \ </span><br><span class="line">-v /data/nginx/conf:/etc/nginx \ </span><br><span class="line">-d nginx:1.10</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><p><strong>RabbitMQ安装</strong></p><ul><li>下载rabbitmq3.7.15的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.15</span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动RabbitMQ服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5672:5672 -p 15672:15672 --name=rabbitmq \ -d rabbitmq:3.7.15</span><br></pre></td></tr></table></figure><ul><li>进入容器并开启管理功能：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/rabbitmq1.png" alt="开启管理功能" /></p><ul><li>开启防火墙：<ul><li>查看firewalld状态:<code>systemctl status firewalld</code>，如果是dead状态，即防火墙未开启</li><li>开启防火墙<code>systemctl start firewalld</code></li><li>确认firewalld状态:<code>systemctl status firewalld</code></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent firewall-cmd --reload</span><br></pre></td></tr></table></figure><ul><li>访问地址查看是否安装成功：<a href="http://192.168.172.111:15672/">http://192.168.172.111:15672</a></li></ul><p><img src="/Users/wustmz/Documents/mqlogin.png" alt="mqlogin" /></p><ul><li>输入账号密码并登录：guest guest</li><li>创建帐号并设置其角色为管理员：mall mall</li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/add-user.png" alt="add-user" /></p><ul><li>创建一个新的虚拟host为：/mall</li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/add-host.png" alt="add-host" /></p><ul><li>点击mall用户进入用户配置页面</li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/user-admin.png" alt="user-admin" /></p><ul><li>给mall用户配置该虚拟host的权限</li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/add-permission.png" alt="add-permission" /></p><hr /><p><strong>Elasticsearch安装</strong></p><ul><li>下载Elasticsearch7.6.2的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.6.2</span><br></pre></td></tr></table></figure><ul><li>修改虚拟内存区域大小，否则会因为过小而无法启动:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144              </span><br></pre></td></tr></table></figure><ul><li>创建文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/elasticsearch/config </span><br><span class="line">mkdir -p /data/elasticsearch/data </span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;/data/elasticsearch/config/elasticsearch.yml </span><br><span class="line">chmod -R 777 /data/elasticsearch/ </span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动Elasticsearch服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name=elasticsearch \ </span><br><span class="line">-e &quot;discovery.type=single-node&quot; \ </span><br><span class="line">-e &quot;cluster.name=elasticsearch&quot; \ </span><br><span class="line">-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \ </span><br><span class="line">-v /data/elasticsearch/data:/usr/share/elasticsearch/data \ </span><br><span class="line">-d elasticsearch:7.6.2 </span><br></pre></td></tr></table></figure><ul><li>启动时会发现/usr/share/elasticsearch/data目录没有访问权限，只需要修改/data/elasticsearch/data目录的权限，再重新启动即可；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /data/elasticsearch/data/</span><br></pre></td></tr></table></figure><ul><li>安装中文分词器IKAnalyzer，并重新启动：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash  </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此命令需要在容器中运行</span> </span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><ul><li>开启防火墙：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9200/tcp --permanent firewall-cmd --reload</span><br></pre></td></tr></table></figure><ul><li>访问会返回版本信息：<a href="http://192.168.172.111:9200/">http://192.168.172.111:9200</a></li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/es.png" alt="es" /></p><hr /><p><strong>Logstash安装</strong></p><ul><li>下载Logstash7.6.2的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull logstash:7.6.2</span><br></pre></td></tr></table></figure><ul><li>修改Logstash的配置文件logstash.conf中output节点下的Elasticsearch连接地址为es:9200，配置文件地址：<code>/document/elk/logstash.conf</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output &#123;  </span><br><span class="line">elasticsearch &#123;    </span><br><span class="line">hosts =&gt; &quot;es:9200&quot;    index =&gt; &quot;mall-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建/data/logstash目录，并将Logstash的配置文件logstash.conf拷贝到该目录；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logstash</span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动Logstash服务；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=logstash -p 4560:4560 -p 4561:4561 -p 4562:4562 -p 4563:4563 \ </span><br><span class="line">--link elasticsearch:es \ </span><br><span class="line">-v /data/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf \ </span><br><span class="line">-d logstash:7.6.2 </span><br></pre></td></tr></table></figure><ul><li>进入容器内部，安装<code>json_lines</code>插件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logstash-plugin install logstash-codec-json_lines</span><br></pre></td></tr></table></figure><hr /><p><strong>Kibana安装</strong></p><ul><li>下载Kibana7.6.2的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.6.2</span><br></pre></td></tr></table></figure><ul><li>使用如下命令启动Kibana服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -p 5601:5601 \ </span><br><span class="line">--link elasticsearch:es \ </span><br><span class="line">-e &quot;elasticsearch.hosts=http://es:9200&quot; \ </span><br><span class="line">-d kibana:7.6.2</span><br></pre></td></tr></table></figure><p>开启防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5601/tcp --permanent firewall-cmd --reload</span><br></pre></td></tr></table></figure><ul><li>访问地址进行测试：<a href="http://192.168.172.111:5601/">http://192.172.3.111:5601</a></li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/kibana.png" alt="kibana" /></p><hr /><p><strong>MongoDB安装</strong></p><ul><li>下载MongoDB4.2.5的docker镜像：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo:4.2.5</span><br></pre></td></tr></table></figure><ul><li>使用docker命令启动：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 27017:27017 --name mongo \ -v /mydata/mongo/db:/data/db \ -d mongo:4.2.5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构师 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01.Tomcat处理请求过程</title>
      <link href="/2021/11/24/Tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/11/24/Tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是Tomcat底层原理解析系列的第一篇，详细介绍Tomcat是如何处理请求的</p></blockquote><p>Tomcat通过<strong>Endpoint</strong>组件接收socket连接，接收到⼀个socket连接后会执⾏如下步骤：</p><ol><li>第⼀次从socket中获取数据到InputBuffer中，BIO对应的是InternalInputBuffer，⽗类是</li></ol><p>AbstractInputBuffer</p><ol start="2"><li><p>然后基于InputBuffer进⾏解析数据</p></li><li><p>先解析请求⾏，把请求⽅法，请求uri，请求协议等封装到org.apache.coyote.Request对象中</p></li><li><p>org.apache.coyote.Request中的属性都是MessageBytes类型，直接可以理解为字节类型，因为从</p></li></ol><p>socket中获取的数据都是字节，在解析过程中不⽤直接把字节转成字符串，并且MessageBytes虽然表</p><p>示字节，但是它并不会真正的存储字节，还是使⽤ByteChunk基于InputBuffer中的字节数组来进⾏标</p><p>记，标记字节数组中的哪个⼀个范围表示请求⽅法，哪个⼀个范围表示请求uri等等。</p><ol start="5"><li><p>然后解析头，和解析请求⾏类似</p></li><li><p>解析完请求头后，就基于请求头来初始化⼀些参数，⽐如Connection是keepalive是close，⽐如是否</p></li></ol><p>有Content-length，并且对于的⻓度是多少等等，还包括当前请求在处理请求体时应该使⽤哪个</p><p>InputFilter。</p><ol start="7"><li><p>然后将请求交给容器</p></li><li><p>容器再将请求交给具体的servlet进⾏处理</p></li><li><p>servlet在处理请求的过程中会利⽤response进⾏响应，返回数据给客户端，⼀个普通的响应过程会把</p></li></ol><p>数据先写⼊⼀个缓冲区，当调⽤flush，或者close⽅法时会把缓冲区中的内容发送给socet，下⾯有⼀</p><p>篇单独的⽂章讲解tomcat响应请求过程</p><ol start="10"><li><p>servlet处理完请求后，先会检查是否需要把响应数据发送给socket</p></li><li><p>接着看当前请求的请求体是否处理结束，是否还有剩余数据，如果有剩余数据需要把这些数据处理掉，</p></li></ol><p>以便能够获取到下⼀个请求的数据</p><ol start="12"><li>然后回到第⼀步开始处理下⼀个请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构师 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装homebrew</title>
      <link href="/2021/11/21/Mac%E5%AE%89%E8%A3%85homebrew/"/>
      <url>/2021/11/21/Mac%E5%AE%89%E8%A3%85homebrew/</url>
      
        <content type="html"><![CDATA[<h3 id="mac安装homebrew国内用户"><a class="markdownIt-Anchor" href="#mac安装homebrew国内用户"></a> Mac安装homebrew（国内用户）</h3><blockquote><p>国内用户安装homebrew经常会因为网络问题安装失败，使用如下命令可以解决</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><p>此行命令来源于：<a href="https://zhuanlan.zhihu.com/p/111014448">金牛肖马</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.类加载机制详解</title>
      <link href="/2021/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1类加载运行全过程"><a class="markdownIt-Anchor" href="#1类加载运行全过程"></a> 1.类加载运行全过程</h3><p>当我们用Java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> initData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;  <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="通过java命令执行代码的大体流程如下"><a class="markdownIt-Anchor" href="#通过java命令执行代码的大体流程如下"></a> 通过Java命令执行代码的大体流程如下：</h5><p><img src="https://github.com/wustmz/oss/raw/main/uPic/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="类加载机制" /></p><p>其中loadClass的类加载过程有如下几步：</p><blockquote><p>加载→验证→准备→解析→初始化→使用→卸载</p></blockquote><ul><li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的<strong>java.lang.class</strong>对象，作为方法区这个类的各种数据的访问入口</li><li>验证：校验字节码文件的正确性</li><li>准备：给类的静态变量分配内存，并赋予默认值</li><li>解析：将<strong>符号引用</strong>替换为直接引用，该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存内存的指针或句柄等（直接引用），这是所谓的<strong>静态链接</strong>过程（类加载期间完成），<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用。</li><li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li></ul><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/1.2.png" alt="详细流程" /></p><p>类被加载到方法区中后主要包含：<strong>运行常量池</strong>、<strong>类型信息</strong>、<strong>字段信息</strong>、<strong>方法信息</strong>、<strong>类加载器的引用</strong>、对应class实例的引用等信息。</p><p>类加载器的引用：这个类到类加载器实例的引用</p><p>对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class类型的对象实例放到堆（Heap）中，作为开发人员访问方法区中类定义的入口和切入口。</p><p><strong>注意</strong>，主类在运行过程中如果使用到其他类，会逐步加载这些类。</p><p>jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamicLoad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load TestDynamicLoad************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load test************&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">null</span>;  <span class="comment">//B不会加载，除非这里执行 new B()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">*************load TestDynamicLoad************</span><br><span class="line">*************load A************</span><br><span class="line">*************initial A************</span><br><span class="line">*************load test************</span><br></pre></td></tr></table></figure><h3 id="2类加载器和双亲委派机制"><a class="markdownIt-Anchor" href="#2类加载器和双亲委派机制"></a> 2.类加载器和双亲委派机制</h3><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p><ul><li>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等</li><li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的jar类包</li><li>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ul><p>看一个类加载器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDKClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.class.getClassLoader());</span><br><span class="line">        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        ClassLoader extClassloader = appClassLoader.getParent();</span><br><span class="line">        ClassLoader bootstrapLoader = extClassloader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the extClassloader : &quot;</span> + extClassloader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the appClassLoader : &quot;</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrapLoader加载以下文件：&quot;</span>);</span><br><span class="line">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            System.out.println(urls[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;extClassloader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;appClassLoader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">the bootstrapLoader : <span class="keyword">null</span></span><br><span class="line">the extClassloader : sun.misc.Launcher$ExtClassLoader@2dda6444</span><br><span class="line">the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">bootstrapLoader加载以下文件：</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/classes</span><br><span class="line"></span><br><span class="line">extClassloader加载以下文件：</span><br><span class="line">/Users/wustmz/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line"></span><br><span class="line">appClassLoader加载以下文件：</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_291</span>.jdk/Contents/Home/lib/tools.jar:/Users/wustmz/IdeaProjects/Freedom/jvm/target/classes:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-starter-web/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-starter-web-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-starter/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-starter-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-autoconfigure-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-starter-logging/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-starter-logging-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/ch/qos/logback/logback-classic/<span class="number">1.2</span><span class="number">.3</span>/logback-classic-<span class="number">1.2</span><span class="number">.3</span>.jar:/Users/wustmz/.m2/repository/ch/qos/logback/logback-core/<span class="number">1.2</span><span class="number">.3</span>/logback-core-<span class="number">1.2</span><span class="number">.3</span>.jar:/Users/wustmz/.m2/repository/org/apache/logging/log4j/log4j-to-slf4j/<span class="number">2.11</span><span class="number">.1</span>/log4j-to-slf4j-<span class="number">2.11</span><span class="number">.1</span>.jar:/Users/wustmz/.m2/repository/org/apache/logging/log4j/log4j-api/<span class="number">2.11</span><span class="number">.1</span>/log4j-api-<span class="number">2.11</span><span class="number">.1</span>.jar:/Users/wustmz/.m2/repository/org/slf4j/jul-to-slf4j/<span class="number">1.7</span><span class="number">.25</span>/jul-to-slf4j-<span class="number">1.7</span><span class="number">.25</span>.jar:/Users/wustmz/.m2/repository/javax/annotation/javax.annotation-api/<span class="number">1.3</span><span class="number">.2</span>/javax.annotation-api-<span class="number">1.3</span><span class="number">.2</span>.jar:/Users/wustmz/.m2/repository/org/yaml/snakeyaml/<span class="number">1.23</span>/snakeyaml-<span class="number">1.23</span>.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-starter-json/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-starter-json-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/core/jackson-databind/<span class="number">2.9</span><span class="number">.8</span>/jackson-databind-<span class="number">2.9</span><span class="number">.8</span>.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/<span class="number">2.9</span><span class="number">.0</span>/jackson-annotations-<span class="number">2.9</span><span class="number">.0</span>.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/core/jackson-core/<span class="number">2.9</span><span class="number">.8</span>/jackson-core-<span class="number">2.9</span><span class="number">.8</span>.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/<span class="number">2.9</span><span class="number">.8</span>/jackson-datatype-jdk8-<span class="number">2.9</span><span class="number">.8</span>.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/<span class="number">2.9</span><span class="number">.8</span>/jackson-datatype-jsr310-<span class="number">2.9</span><span class="number">.8</span>.jar:/Users/wustmz/.m2/repository/com/fasterxml/jackson/<span class="keyword">module</span>/jackson-<span class="keyword">module</span>-parameter-names/<span class="number">2.9</span><span class="number">.8</span>/jackson-<span class="keyword">module</span>-parameter-names-<span class="number">2.9</span><span class="number">.8</span>.jar:/Users/wustmz/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/<span class="number">2.1</span><span class="number">.2</span>.RELEASE/spring-boot-starter-tomcat-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/<span class="number">9.0</span><span class="number">.14</span>/tomcat-embed-core-<span class="number">9.0</span><span class="number">.14</span>.jar:/Users/wustmz/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/<span class="number">9.0</span><span class="number">.14</span>/tomcat-embed-el-<span class="number">9.0</span><span class="number">.14</span>.jar:/Users/wustmz/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/<span class="number">9.0</span><span class="number">.14</span>/tomcat-embed-websocket-<span class="number">9.0</span><span class="number">.14</span>.jar:/Users/wustmz/.m2/repository/org/hibernate/validator/hibernate-validator/<span class="number">6.0</span><span class="number">.14</span>.Final/hibernate-validator-<span class="number">6.0</span><span class="number">.14</span>.Final.jar:/Users/wustmz/.m2/repository/javax/validation/validation-api/<span class="number">2.0</span><span class="number">.1</span>.Final/validation-api-<span class="number">2.0</span><span class="number">.1</span>.Final.jar:/Users/wustmz/.m2/repository/org/jboss/logging/jboss-logging/<span class="number">3.3</span><span class="number">.2</span>.Final/jboss-logging-<span class="number">3.3</span><span class="number">.2</span>.Final.jar:/Users/wustmz/.m2/repository/com/fasterxml/classmate/<span class="number">1.4</span><span class="number">.0</span>/classmate-<span class="number">1.4</span><span class="number">.0</span>.jar:/Users/wustmz/.m2/repository/org/springframework/spring-web/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-web-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-beans/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-beans-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-webmvc/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-webmvc-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-aop/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-aop-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-context/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-context-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-expression/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-expression-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/projectlombok/lombok/<span class="number">1.18</span><span class="number">.4</span>/lombok-<span class="number">1.18</span><span class="number">.4</span>.jar:/Users/wustmz/.m2/repository/org/slf4j/slf4j-api/<span class="number">1.7</span><span class="number">.25</span>/slf4j-api-<span class="number">1.7</span><span class="number">.25</span>.jar:/Users/wustmz/.m2/repository/org/springframework/spring-core/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-core-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/springframework/spring-jcl/<span class="number">5.1</span><span class="number">.4</span>.RELEASE/spring-jcl-<span class="number">5.1</span><span class="number">.4</span>.RELEASE.jar:/Users/wustmz/.m2/repository/org/apache/commons/commons-lang3/<span class="number">3.8</span><span class="number">.1</span>/commons-lang3-<span class="number">3.8</span><span class="number">.1</span>.jar:/Users/wustmz/.m2/repository/com/google/code/gson/gson/<span class="number">2.8</span><span class="number">.5</span>/gson-<span class="number">2.8</span><span class="number">.5</span>.jar:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="类加载器初始化过程"><a class="markdownIt-Anchor" href="#类加载器初始化过程"></a> 类加载器初始化过程</h5><p>参见类运行加载全过程图可知其中会创建JVM启动器示例sun.misc.Launcher。</p><p>在Launcher构造方法内部，其构建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。</p><p>JVM默认使用Launcher的getClassLoader()方法返回类加载器AppClassLoader的实例加载我们的应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Launcher的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造扩展类加载器，在构造的过程中将其父加载器设置为null</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span></span><br><span class="line">        <span class="comment">//Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span></span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">    String var2 = System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">    。。。 。。。 <span class="comment">//省略一些不需关注代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h5><p>JVM类加载器是有亲子层级结构的，如下图</p><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/1.3.png" alt="双亲委派模型" /></p><p>这里类加载其实就有一个双亲委派机制，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。</p><p>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没有找到Math类，又向下退回Math类的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了</p><p><strong>双亲委派机制说简单点就是，先找到父亲加载，不行再由儿子自己加载</strong></p><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：</p><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么要设计双亲委派机制"><a class="markdownIt-Anchor" href="#为什么要设计双亲委派机制"></a> 为什么要设计双亲委派机制？</h5><ul><li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li><li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong></li></ul><p>看一个类加载示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h5 id="全盘负责委托机制"><a class="markdownIt-Anchor" href="#全盘负责委托机制"></a> 全盘负责委托机制</h5><p>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</p><h5 id="自定义类加载器示例"><a class="markdownIt-Anchor" href="#自定义类加载器示例"></a> 自定义类加载器示例：</h5><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了<strong>双亲委派机制</strong>，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是<strong>重写findClass方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//D盘创建 test/com/tuling/jvm 几级目录，将User类的复制类User1.class丢入该目录</span></span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure><h5 id="打破双亲委派机制"><a class="markdownIt-Anchor" href="#打破双亲委派机制"></a> 打破双亲委派机制</h5><p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的 java.lang.String.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试用自己改写类加载机制去加载自己写的java.lang.String.class</span></span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">659</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure><h5 id="tomcat打破双亲委派机制"><a class="markdownIt-Anchor" href="#tomcat打破双亲委派机制"></a> Tomcat打破双亲委派机制</h5><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？</p><p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：</p><ol><li><p>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</p></li><li><p>部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。</p></li><li><p><strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</p></li><li><p>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p></li></ol><p>再看看我们的问题：<strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong></p><p>答案是不行的。为什么？</p><p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p><p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。</p><p>第三个问题和第一个问题一样。</p><p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p><h5 id="tomcat自定义加载器详解"><a class="markdownIt-Anchor" href="#tomcat自定义加载器详解"></a> Tomcat自定义加载器详解</h5><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/Tomcat%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="Tomcat自定义加载器" /></p><p>tomcat的几个主要类加载器：</p><ul><li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li><li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li><li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li><li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本；</li></ul><p>从图中的委派关系中可以看出：</p><p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</p><p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p><p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p><p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗？答案是：违背了。</p><p>很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，<strong>每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制</strong>。</p><p><strong>模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = fis.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//非自定义的类还是走双亲委派加载</span></span><br><span class="line">                    <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;com.tuling.jvm&quot;</span>))&#123;</span><br><span class="line">                        c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:/test1&quot;</span>);</span><br><span class="line">        Class clazz1 = classLoader1.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        Object obj1 = clazz1.newInstance();</span><br><span class="line">        Method method1= clazz1.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        method1.invoke(obj1, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(clazz1.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@266474c2</span><br><span class="line"></span><br><span class="line">=======另外一个User1版本：自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@66d3c617</span><br></pre></td></tr></table></figure><p>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</p><h5 id="模拟实现tomcat的jasperloader热加载"><a class="markdownIt-Anchor" href="#模拟实现tomcat的jasperloader热加载"></a> 模拟实现Tomcat的JasperLoader热加载</h5><p>原理：后台启动线程监听jsp文件变化，如果变化了找到该jsp对应的servlet类的加载器引用(gcroot)，重新生成新的<strong>JasperLoader</strong>加载器赋值给引用，然后加载新的jsp对应的servlet类，之前的那个加载器因为没有gcroot引用了，下一次gc的时候会被销毁。</p><p>附下User类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======自己的加载器加载类调用方法=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="补充hotspot源码jvm启动执行main方法流程"><a class="markdownIt-Anchor" href="#补充hotspot源码jvm启动执行main方法流程"></a> 补充：Hotspot源码JVM启动执行main方法流程</h5><p><img src="https://raw.githubusercontent.com/wustmz/oss/main/img/Hotspot%E6%BA%90%E7%A0%81JVM%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8Cmain%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.jpg" alt="Hotspot源码JVM启动执行main方法流程" /></p>]]></content>
      
      
      <categories>
          
          <category> 性能调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Focus and make it better</title>
      <link href="/2021/11/18/Focus-and-make-it-better/"/>
      <url>/2021/11/18/Focus-and-make-it-better/</url>
      
        <content type="html"><![CDATA[<p>If u want it，make u deserve it。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
